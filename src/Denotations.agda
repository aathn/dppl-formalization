open import Lib.Reals

module Denotations (R : Reals‚ÇÄ) where

open Reals R using (‚Ñù; 0·¥ø; _‚â≤?_)

open import Syntax R hiding (n; m; D)
open import Typing R

open import Lib.Prelude hiding ([]; _‚à∑_; _‚àà_)
open import Lib.Unfinite
open import Lib.Env hiding ([]; _‚à∑_)
open import Lib.Subvec

open import Data.Fin using (splitAt)
open import Data.Fin.Properties using (to‚Ñï<n)
open import Data.List.Relation.Unary.All as All using (All)
open import Data.Vec.Functional
open import Relation.Unary using (_‚àà_; Pred)
open import Relation.Binary.PropositionalEquality using (_‚âó_)

private
  variable
    n m k : ‚Ñï
    Œò : Coeff ^ n
    Œò‚Ä≤ : Coeff ^ m
    Œò‚Ä≥ : Coeff ^ k

record ùîâ-assumptions : Set‚ÇÅ where
  field
    ùîâ : (Œò : Coeff ^ n) ‚Üí Coeff ‚Üí Pred (‚Ñù ^ n ‚Üí ‚Ñù) ‚Ñì‚ÇÄ

  ùîâ‚Ä≤ : (Œò : Coeff ^ n) (Œò‚Ä≤ : Coeff ^ m) ‚Üí Pred (‚Ñù ^ n ‚Üí ‚Ñù ^ m) ‚Ñì‚ÇÄ
  ùîâ‚Ä≤ Œò Œò‚Ä≤ f = (i : Fin _) ‚Üí œÄ[ i ] ‚àò f ‚àà ùîâ Œò (œÄ[ i ] Œò‚Ä≤)

  field
    ùîâ-const : (r : ‚Ñù) ‚Üí const r ‚àà ùîâ [] N

    ùîâ-proj : id ‚àà ùîâ‚Ä≤ Œò Œò

    ùîâ-cond :
      (Œª Œ∏ ‚Üí if (Œ∏ ‚ÇÄ ‚â≤? 0·¥ø) then Œ∏ ‚ÇÅ else Œ∏ ‚ÇÇ)
        ‚àà ùîâ (P ‚à∑ c ‚à∑ c ‚à∑ []) c

    ùîâ-compose :
      {g : ‚Ñù ^ n ‚Üí ‚Ñù ^ m}
      {f : ‚Ñù ^ m ‚Üí ‚Ñù}
      (_ : g ‚àà ùîâ‚Ä≤ Œò Œò‚Ä≤)
      (_ : f ‚àà ùîâ Œò‚Ä≤ c)
      ‚Üí -----------------
       f ‚àò g ‚àà ùîâ Œò c

    ùîâ-sub :
      {f : ‚Ñù ^ n ‚Üí ‚Ñù}
      (_ : ‚àÄ i ‚Üí œÄ[ i ] Œò ‚â§‚Ä≤ œÄ[ i ] Œò‚Ä≤)
      (_ : c‚Ä≤ ‚â§‚Ä≤ c)
      ‚Üí -------------------------------
      f ‚àà ùîâ Œò c ‚Üí f ‚àà ùîâ Œò‚Ä≤ c‚Ä≤

    ùîâ-promote :
      {f : ‚Ñù ^ n ‚Üí ‚Ñù}
      (_ : ‚àÄ i ‚Üí c‚Ä≤ ‚â§‚Ä≤ œÄ[ i ] Œò)
      ‚Üí ------------------------
      f ‚àà ùîâ Œò c ‚Üí f ‚àà ùîâ Œò c‚Ä≤


module ùîâ-lemmas (Ass : ùîâ-assumptions) where
  open ùîâ-assumptions Ass

  ùîâ-const‚Ä≤ : (Œ∏ : ‚Ñù ^ n) ‚Üí const Œ∏ ‚àà ùîâ‚Ä≤ Œò Œò‚Ä≤
  ùîâ-const‚Ä≤ Œ∏ i =
    ùîâ-compose {Œò‚Ä≤ = Œª ()} {g = Œª _ ()} (Œª ()) $
    ùîâ-sub (Œª ()) (‚â§-1 $ to‚Ñï<n _) $
    ùîâ-const _

  ùîâ-compose‚Ä≤ :
    {g : ‚Ñù ^ n ‚Üí ‚Ñù ^ m}
    {f : ‚Ñù ^ m ‚Üí ‚Ñù ^ k}
    (_ : g ‚àà ùîâ‚Ä≤ Œò Œò‚Ä≤)
    (_ : f ‚àà ùîâ‚Ä≤ Œò‚Ä≤ Œò‚Ä≥)
    ‚Üí -----------------
     f ‚àò g ‚àà ùîâ‚Ä≤ Œò Œò‚Ä≥
  ùîâ-compose‚Ä≤ Hg Hf = ùîâ-compose Hg ‚àò Hf

  ùîâ-++ :
    {f : ‚Ñù ^ n ‚Üí ‚Ñù ^ m}
    {g : ‚Ñù ^ n ‚Üí ‚Ñù ^ k}
    (_ : f ‚àà ùîâ‚Ä≤ Œò Œò‚Ä≤)
    (_ : g ‚àà ùîâ‚Ä≤ Œò Œò‚Ä≥)
    ‚Üí ----------------------------------
    (Œª Œ∏ ‚Üí f Œ∏ ++ g Œ∏) ‚àà ùîâ‚Ä≤ Œò (Œò‚Ä≤ ++ Œò‚Ä≥)
  ùîâ-++ {m = m} Hf Hg i with splitAt m i
  ... | Œπ‚ÇÅ i = Hf i
  ... | Œπ‚ÇÇ i = Hg i

  ùîâ-papply :
    {f : ‚Ñù ^ (n + m) ‚Üí ‚Ñù}
    (_ : f ‚àà ùîâ (Œò ++ Œò‚Ä≤) c)
    (Œ∏‚Ä≤ : ‚Ñù ^ m)
    ‚Üí -------------------------
    (Œª Œ∏ ‚Üí f (Œ∏ ++ Œ∏‚Ä≤)) ‚àà ùîâ Œò c
  ùîâ-papply Hf Œ∏ =
    ùîâ-compose (ùîâ-++ ùîâ-proj (ùîâ-const‚Ä≤ _)) Hf

  ùîâ-proj‚Ä≤ : (H‚äÜ : Œò ‚äÜ Œò‚Ä≤) ‚Üí proj-‚äÜ (H‚äÜ .œÄ‚ÇÅ) ‚àà ùîâ‚Ä≤ Œò‚Ä≤ Œò
  ùîâ-proj‚Ä≤ {Œò‚Ä≤ = Œò‚Ä≤} H‚äÜ i rewrite H‚äÜ .œÄ‚ÇÇ i = ùîâ-proj _

  ùîâ-weaken :
    {f : ‚Ñù ^ n ‚Üí ‚Ñù}
    (H‚äÜ : Œò ‚äÜ Œò‚Ä≤)
    ‚Üí ---------------------------------------
    f ‚àà ùîâ Œò c ‚Üí f ‚àò proj-‚äÜ (H‚äÜ .œÄ‚ÇÅ) ‚àà ùîâ Œò‚Ä≤ c
  ùîâ-weaken H‚äÜ Hf = ùîâ-compose (ùîâ-proj‚Ä≤ H‚äÜ) Hf


record DenotAssumptions : Set‚ÇÅ where
  field
    ùîâ-ass : ùîâ-assumptions

  open ùîâ-assumptions ùîâ-ass public
  open ùîâ-lemmas ùîâ-ass public

  field
    ‚ü¶_‚üß·¥æ : (œï : Prim) ‚Üí ‚Ñù ^ PrimAr œï ‚Üí ‚Ñù

    ùîâ-prim :
      {Œò : Coeff ^ PrimAr œï}
      (_ : PrimTy œï ‚â° (Œò , c))
      ‚Üí ----------------------
      ‚ü¶ œï ‚üß·¥æ ‚àà ùîâ Œò c

    ùê∑ :
      (f : ‚Ñù ^ n ‚Üí ‚Ñù)
      (_ : ‚àÄ i ‚Üí œÄ[ i ] Œò ‚â§‚Ä≤ P)
      (_ : f ‚àà ùîâ Œò c)
      ‚Üí -----------------------
      ‚Ñù ^ (n + n) ‚Üí ‚Ñù

    ùîâ-diff :
      {Œò‚Ä≤ : Coeff ^ m}
      (f : ‚Ñù ^ (n + m) ‚Üí ‚Ñù)
      (H‚â§ : ‚àÄ i ‚Üí œÄ[ i ] Œò ‚â§‚Ä≤ P)
      (Hf : f ‚àà ùîâ (Œò ++ Œò‚Ä≤) c)
      ‚Üí ------------------------------------------------------
      (Œª xvŒ∏ ‚Üí ùê∑ _ H‚â§ (ùîâ-papply Hf (drop _ xvŒ∏)) (take _ xvŒ∏))
        ‚àà ùîâ ((Œò ++ replicate n A) ++ Œò‚Ä≤) c


module Denotations (Ass : DenotAssumptions) where
  open DenotAssumptions Ass

  -- Our semantic domain, inspired by the paper
  -- Concrete Categories for Higher-order Recursion (Matache et al.).
  --
  -- In terms of that paper, the idea is that our domains are concrete
  -- sheaves over a site S whose objects are vectors of coeffects, and
  -- whose morphisms Œò ‚Üí Œò‚Ä≤ are functions (f : ‚Ñù ^ n ‚Üí ‚Ñù ^ m) ‚àà ùîâ‚Ä≤ Œò Œò‚Ä≤.
  -- TODO: What is the coverage on the site?  Can it simply be trivial?
  -- Should the objects be _subsets_ of ‚Ñù ^ n tagged with vectors of
  -- coeffects instead, and the coverage be the inclusion functions?
  --
  -- The semantics is also closely related to our previous logical
  -- relations arguments, in that we can view each domain as a set
  -- equipped with a parameterized predicate describing the
  -- well-behaved maps into that domain.
  record ùîá : Set‚ÇÅ where
    constructor mkùîá
    field
      ‚à£_‚à£ : Set
      R[_,_] : {n : ‚Ñï} ‚Üí Coeff ^ n ‚Üí Pred (‚Ñù ^ n ‚Üí ‚à£_‚à£) ‚Ñì‚ÇÄ

      R[,]-const :
        (x : ‚à£_‚à£)
        ‚Üí ---------------
        const x ‚àà R[_,_] Œò

      R[,]-compose :
        {f : ‚Ñù ^ n ‚Üí ‚Ñù ^ m}
        {œï : ‚Ñù ^ m ‚Üí ‚à£_‚à£}
        (_ : f ‚àà ùîâ‚Ä≤ Œò Œò‚Ä≤)
        ‚Üí ------------------------------
        œï ‚àà R[_,_] Œò‚Ä≤ ‚Üí œï ‚àò f ‚àà R[_,_] Œò

  open ùîá

  -- Conjecture: the previous semantics and this one are equivalent
  -- under the following correspondence:

  module Correspondence where
    fwd :
      (p : {n : ‚Ñï} ‚Üí Pred (Coeff ^ n) ‚Ñì‚ÇÄ)
      (pr : {m : ‚Ñï} {Œò : Coeff ^ m} ‚Üí p Œò ‚Üí ‚Ñù ^ m ‚Üí p [])
      ‚Üí ---------------------------------------------------
      ‚àÉ Œª X ‚Üí {m : ‚Ñï} ‚Üí Coeff ^ m ‚Üí Pred (‚Ñù ^ m ‚Üí X) ‚Ñì‚ÇÄ
    fwd p pr = p [] , Œª Œò f ‚Üí ‚àë f‚Ä≤ ‚à∂ p Œò , pr f‚Ä≤ ‚âó f

    bwd :
      {X : Set}
      (_ : {m : ‚Ñï} ‚Üí Coeff ^ m ‚Üí Pred (‚Ñù ^ m ‚Üí X) ‚Ñì‚ÇÄ)
      ‚Üí -----------------------------------------------
      {n : ‚Ñï} ‚Üí Pred (Coeff ^ n) ‚Ñì‚ÇÄ
    bwd Hx = Œª Œò ‚Üí ‚àÉ (Hx Œò)

    -- Note that this is not a proper equivalence as the forward
    -- direction requires a projection function from p Œò
    -- to ‚Ñù ^ m ‚Üí p [].  Attempting to take this into account in the
    -- reverse direction requires adding more hypotheses stating that
    -- constant functions are plots, and furthermore that they are the
    -- only plots of Hx [].  This gets a bit intricate, but I believe
    -- the required hypotheses should hold for our case.


  ùîá-is-hom : (D‚ÇÅ D‚ÇÇ : ùîá) ‚Üí Pred (‚à£ D‚ÇÅ ‚à£ ‚Üí ‚à£ D‚ÇÇ ‚à£) ‚Ñì‚ÇÄ
  ùîá-is-hom D‚ÇÅ D‚ÇÇ f =
    {m : ‚Ñï} {Œò : Coeff ^ m}
    ‚Üí -----------------------------------------
    ‚àÄ œï ‚Üí œï ‚àà R[ D‚ÇÅ , Œò ] ‚Üí f ‚àò œï ‚àà R[ D‚ÇÇ , Œò ]

  record ùîá-hom (D‚ÇÅ D‚ÇÇ : ùîá) : Set where
    field
      to : ‚à£ D‚ÇÅ ‚à£ ‚Üí ‚à£ D‚ÇÇ ‚à£
      is-hom : ùîá-is-hom D‚ÇÅ D‚ÇÇ to

  open ùîá-hom

  private
    variable
      D D‚ÇÅ D‚ÇÇ D‚ÇÉ : ùîá

  ùîá-id : ùîá-hom D D
  ùîá-id .to z = z
  ùîá-id .is-hom _ Hœï = Hœï

  _ùîá‚àò_ : ùîá-hom D‚ÇÇ D‚ÇÉ ‚Üí ùîá-hom D‚ÇÅ D‚ÇÇ ‚Üí ùîá-hom D‚ÇÅ D‚ÇÉ
  (f ùîá‚àò g) .to = f .to ‚àò g .to
  (f ùîá‚àò g) .is-hom _ = f .is-hom _ ‚àò g .is-hom _

  ùîáùüô : ùîá
  ùîáùüô = mkùîá ùüô (Œª _ _ ‚Üí ùüô) (Œª _ ‚Üí tt) Œª _ _ ‚Üí tt

  ùîáùüô-terminal : ùîá-hom D ùîáùüô
  ùîáùüô-terminal .to _ = tt
  ùîáùüô-terminal .is-hom _ _ = tt

  ùîá‚Ñù : Coeff ‚Üí ùîá
  ùîá‚Ñù c =
    mkùîá ‚Ñù (Œª Œò ‚Üí ùîâ Œò c) (Œª r ‚Üí ùîâ-const‚Ä≤ {Œò‚Ä≤ = c ‚à∑ []} (r ‚à∑ []) ‚ÇÄ) ùîâ-compose

  ùîá-const : ‚Ñù ‚Üí ùîá-hom ùîáùüô (ùîá‚Ñù c)
  ùîá-const r .to _ = r
  ùîá-const r .is-hom _ _ = R[,]-const (ùîá‚Ñù _) r

  ùîá‚Ñù‚Ä≤ : Coeff ^ n ‚Üí ùîá
  ùîá‚Ñù‚Ä≤ Œò‚Ä≤ = mkùîá (‚Ñù ^ _) (Œª Œò ‚Üí ùîâ‚Ä≤ Œò Œò‚Ä≤) ùîâ-const‚Ä≤ ùîâ-compose‚Ä≤

  _ùîá√ó_ : ùîá ‚Üí ùîá ‚Üí ùîá
  ‚à£ D‚ÇÅ ùîá√ó D‚ÇÇ ‚à£ = ‚à£ D‚ÇÅ ‚à£ √ó ‚à£ D‚ÇÇ ‚à£
  R[ D‚ÇÅ ùîá√ó D‚ÇÇ , Œò ] f = œÄ‚ÇÅ ‚àò f ‚àà R[ D‚ÇÅ , Œò ] √ó œÄ‚ÇÇ ‚àò f ‚àà R[ D‚ÇÇ , Œò ]
  R[,]-const (D‚ÇÅ ùîá√ó D‚ÇÇ) (x‚ÇÅ , x‚ÇÇ) = R[,]-const D‚ÇÅ x‚ÇÅ , R[,]-const D‚ÇÇ x‚ÇÇ
  R[,]-compose (D‚ÇÅ ùîá√ó D‚ÇÇ) Hf (Hœï‚ÇÅ , Hœï‚ÇÇ) =
    R[,]-compose D‚ÇÅ Hf Hœï‚ÇÅ , R[,]-compose D‚ÇÇ Hf Hœï‚ÇÇ

  ùîáœÄ‚ÇÅ : ùîá-hom (D‚ÇÅ ùîá√ó D‚ÇÇ) D‚ÇÅ
  ùîáœÄ‚ÇÅ .to = œÄ‚ÇÅ
  ùîáœÄ‚ÇÅ .is-hom _ Hœï = Hœï .œÄ‚ÇÅ

  ùîáœÄ‚ÇÇ : ùîá-hom (D‚ÇÅ ùîá√ó D‚ÇÇ) D‚ÇÇ
  ùîáœÄ‚ÇÇ .to = œÄ‚ÇÇ
  ùîáœÄ‚ÇÇ .is-hom _ Hœï = Hœï .œÄ‚ÇÇ

  ùîá‚ü®_,_‚ü© : ùîá-hom D D‚ÇÅ ‚Üí ùîá-hom D D‚ÇÇ ‚Üí ùîá-hom D (D‚ÇÅ ùîá√ó D‚ÇÇ)
  ùîá‚ü® d‚ÇÅ , d‚ÇÇ ‚ü© .to z = d‚ÇÅ .to z , d‚ÇÇ .to z
  ùîá‚ü® d‚ÇÅ , d‚ÇÇ ‚ü© .is-hom œï Hœï = d‚ÇÅ .is-hom œï Hœï , d‚ÇÇ .is-hom œï Hœï

  ùîá‚àè : Vector ùîá n ‚Üí ùîá
  ‚à£ ùîá‚àè Ds ‚à£ = (i : Fin _) ‚Üí ‚à£ Ds i ‚à£
  R[ ùîá‚àè Ds , Œò ] f = (i : Fin _) ‚Üí (Œª Œ∏ ‚Üí f Œ∏ i) ‚àà R[ Ds i , Œò ]
  R[,]-const (ùîá‚àè Ds) x i = R[,]-const (Ds i) (x i)
  R[,]-compose (ùîá‚àè Ds) Hf Hœïs i = R[,]-compose (Ds i) Hf (Hœïs i)

  -- Note: ‚Ñù ^ n ‚â° ‚àè·µ¢‚Åø ‚Ñù holds definitionally.
  _ : ùîá‚àè (ùîá‚Ñù ‚àò Œò) ‚â° ùîá‚Ñù‚Ä≤ Œò
  _ = refl

  ùîáœÄ[_] : {Ds : Vector ùîá n} ‚Üí (i : Fin n) ‚Üí ùîá-hom (ùîá‚àè Ds) (œÄ[ i ] Ds)
  ùîáœÄ[ i ] .to ds = ds i
  ùîáœÄ[ i ] .is-hom _ Hœï = Hœï i

  ùîá‚àè‚ü®_‚ü© : {Ds : Vector ùîá n} ‚Üí ((i : Fin n) ‚Üí ùîá-hom D (Ds i)) ‚Üí ùîá-hom D (ùîá‚àè Ds)
  ùîá‚àè‚ü® ds ‚ü© .to z i = ds i .to z
  ùîá‚àè‚ü® ds ‚ü© .is-hom œï Hœï i = ds i .is-hom œï Hœï

  _ùîá‚áí_ : ùîá ‚Üí ùîá ‚Üí ùîá
  ‚à£ D‚ÇÅ ùîá‚áí D‚ÇÇ ‚à£ = ùîá-hom D‚ÇÅ D‚ÇÇ
  R[ D‚ÇÅ ùîá‚áí D‚ÇÇ , Œò ] f =
    (Œª (Œ∏ , d) ‚Üí f Œ∏ .to d) ‚àà ùîá-is-hom (ùîá‚Ñù‚Ä≤ Œò ùîá√ó D‚ÇÅ) D‚ÇÇ
  R[,]-const (D‚ÇÅ ùîá‚áí D‚ÇÇ) f œï Hœï = f .is-hom (œÄ‚ÇÇ ‚àò œï) (Hœï .œÄ‚ÇÇ)
  R[,]-compose (D‚ÇÅ ùîá‚áí D‚ÇÇ) Hf Hœï‚ÇÄ œï Hœï =
    Hœï‚ÇÄ _ (ùîâ-compose‚Ä≤ (Hœï .œÄ‚ÇÅ) Hf , Hœï .œÄ‚ÇÇ)

  ùîá-eval : ùîá-hom ((D‚ÇÅ ùîá‚áí D‚ÇÇ) ùîá√ó D‚ÇÅ) D‚ÇÇ
  ùîá-eval .to (f , x) = f .to x
  ùîá-eval .is-hom œï (Hœï‚ÇÅ , Hœï‚ÇÇ) = Hœï‚ÇÅ _ (ùîâ-proj , Hœï‚ÇÇ)

  ùîá-curry : ùîá-hom (D ùîá√ó D‚ÇÅ) D‚ÇÇ ‚Üí ùîá-hom D (D‚ÇÅ ùîá‚áí D‚ÇÇ)
  ùîá-curry f .to x .to y = f .to (x , y)
  ùîá-curry {D = D} f .to x .is-hom œï Hœï =
    f .is-hom _ (R[,]-const D x , Hœï)
  ùîá-curry {D = D} f .is-hom œï Hœï œï‚Ä≤ (Hœï‚Ä≤‚ÇÅ , Hœï‚Ä≤‚ÇÇ) =
    f .is-hom _ (R[,]-compose D Hœï‚Ä≤‚ÇÅ Hœï , Hœï‚Ä≤‚ÇÇ)

  -- Coproduct seems somewhat tricky to define: we need to be able to
  -- partition the objects of our site, i.e., ‚Ñù ^ n tagged with vectors
  -- of coeffects.  Probably we would need to have a more fine-grained
  -- site which has objects not just ‚Ñù ^ n but also well-behaved subsets.
  -- Question is how that would interact with the coeffect vectors.
  --
  -- _ùîá‚äé_ : ùîá ‚Üí ùîá ‚Üí ùîá
  -- ‚à£ D‚ÇÅ ùîá‚äé D‚ÇÇ ‚à£ = ‚à£ D‚ÇÅ ‚à£ ‚äé ‚à£ D‚ÇÇ ‚à£
  -- R[_,_] (D‚ÇÅ ùîá‚äé D‚ÇÇ) {n} Œò f =
  --   ‚àÉ Œª ((m , m‚Ä≤) : ‚Ñï √ó ‚Ñï) ‚Üí
  --   ‚àÉ Œª (Heq : ‚Ñù ^ n ‚â° ‚Ñù ^ m ‚äé ‚Ñù ^ m‚Ä≤) ‚Üí
  --   ‚àÉ Œª ((f‚ÇÅ , f‚ÇÇ) : (‚Ñù ^ m ‚Üí ‚à£ D‚ÇÅ ‚à£) √ó (‚Ñù ^ m‚Ä≤ ‚Üí ‚à£ D‚ÇÇ ‚à£)) ‚Üí
  --   f‚ÇÅ ‚àà R[ D‚ÇÅ , take m (subst (Coeff ^_) Heq Œò) ] √ó
  --   f‚ÇÇ ‚àà R[ D‚ÇÇ , drop m (subst (Coeff ^_) Heq Œò) ] √ó
  --   f ‚âó {!!}
  -- R[,]-const (D‚ÇÅ ùîá‚äé D‚ÇÇ) = {!!}
  -- R[,]-compose (D‚ÇÅ ùîá‚äé D‚ÇÇ) = {!!}

  ùîá-prim :
    {Œò : Coeff ^ PrimAr œï}
    (_ : PrimTy œï ‚â° (Œò , c))
    ‚Üí ---------------------
    ùîá-hom (ùîá‚Ñù‚Ä≤ Œò) (ùîá‚Ñù c)
  ùîá-prim {œï = œï} Hœï .to = ‚ü¶ œï ‚üß·¥æ
  ùîá-prim Hœï .is-hom œï‚Ä≤ Hœï‚Ä≤ = ùîâ-compose Hœï‚Ä≤ (ùîâ-prim Hœï)

  -- Doesn't work straight off unless we know what D‚ÇÅ is...
  -- One way is to define this for the case D‚ÇÅ ‚â° ‚ü¶ T ‚üß·µÄ for some
  -- T, so that we can induct over T; the other would be to figure
  -- out general coproducts.
  --
  -- ùîá-if :
  --   (_ : ùîá-hom D D‚ÇÅ)
  --   (_ : ùîá-hom D D‚ÇÅ)
  --   ‚Üí -----------------
  --   ùîá-hom (ùîá‚Ñù P ùîá√ó D) D‚ÇÅ
  -- ùîá-if d‚ÇÅ d‚ÇÇ .to (x , Œ≥) = if (x ‚â≤? 0·¥ø) then d‚ÇÅ .to Œ≥ else d‚ÇÇ .to Œ≥
  -- ùîá-if d‚ÇÅ d‚ÇÇ .is-hom œï (Hœï‚ÇÅ , Hœï‚ÇÇ) =
  --   let foo = d‚ÇÅ .is-hom _ Hœï‚ÇÇ
  --       bar = d‚ÇÇ .is-hom _ Hœï‚ÇÇ
  --   in
  --   {!!}


  ‚ü¶_‚üß·µÄ : Type ‚Üí ùîá
  ‚ü¶ treal c ‚üß·µÄ = ùîá‚Ñù c
  ‚ü¶ T‚ÇÅ ‚áí[ _ ] T‚ÇÇ ‚üß·µÄ = ‚ü¶ T‚ÇÅ ‚üß·µÄ ùîá‚áí ‚ü¶ T‚ÇÇ ‚üß·µÄ
  ‚ü¶ ttup n Ts ‚üß·µÄ = ùîá‚àè (‚ü¶_‚üß·µÄ ‚àò Ts)
  -- Distributions are interpreted trivially for the time being.
  ‚ü¶ tdist T ‚üß·µÄ = ‚ü¶ T ‚üß·µÄ

  ‚ü¶_‚üß·¥± : TyEnv ‚Üí ùîá
  ‚ü¶ Œµ ‚üß·¥± = ùîáùüô
  ‚ü¶ Œì , _ ‚à∂ T ‚üß·¥± = ‚ü¶ Œì ‚üß·¥± ùîá√ó ‚ü¶ T ‚üß·µÄ

  -- weaken : Œò ‚äÜ Œò‚Ä≤ ‚Üí ‚ü¶ T ‚üß·µÄ Œò ‚Üí ‚ü¶ T ‚üß·µÄ Œò‚Ä≤
  -- weaken {T = treal c} H‚äÜ (_ , Hf) = _ , ùîâ-weaken H‚äÜ Hf
  -- weaken {T = T‚ÇÅ ‚áí[ _ ] T‚ÇÇ} H‚äÜ Hf {Œò‚Ä≤ = Œò‚Ä≤} H‚äÜ‚Ä≤ =
  --   Hf (‚äÜ-trans {zs = Œò‚Ä≤} H‚äÜ H‚äÜ‚Ä≤)
  -- weaken {T = ttup n Ts} H‚äÜ Hsem i = weaken H‚äÜ (Hsem i)
  -- weaken {T = tdist T} H‚äÜ Hsem ‚ÇÄ = weaken H‚äÜ (Hsem ‚ÇÄ)

  -- weaken-env : Œò ‚äÜ Œò‚Ä≤ ‚Üí ‚ü¶ Œì ‚üß·¥± Œò ‚Üí ‚ü¶ Œì ‚üß·¥± Œò‚Ä≤
  -- weaken-env H‚äÜ = All.map (weaken H‚äÜ)

  -- abs-real-denot : {cs : Coeff ^ n} ‚Üí ‚ü¶ T ‚üß·µÄ (cs ++ Œò) ‚Üí ‚ü¶ treals n cs ‚áí[ e ] T ‚üß·µÄ Œò
  -- abs-real-denot {n = n} {T = treal c‚Ä≤} {cs = cs} f {Œò‚Ä≤ = Œò‚Ä≤} H‚äÜ xs
  --   with f , Hf ‚Üê weaken (‚äÜ-++‚Å∫ ‚äÜ-refl H‚äÜ) f = _ , ùîâ-compose Hg Hf
  --   where
  --     Hg : (Œª Œ∏ ‚Üí (Œª i ‚Üí xs i .œÄ‚ÇÅ Œ∏) ++ Œ∏) ‚àà ùîâ‚Ä≤ Œò‚Ä≤ (cs ++ Œò‚Ä≤)
  --     Hg i with splitAt n i
  --     ... | Œπ‚ÇÅ i = xs i .œÄ‚ÇÇ
  --     ... | Œπ‚ÇÇ i = ùîâ-proj i
  -- abs-real-denot {T = T‚ÇÅ ‚áí[ _ ] T‚ÇÇ} {cs = cs} Hf H‚äÜ xs {Œò‚Ä≤ = Œò‚Ä≤} H‚äÜ‚Ä≤ s =
  --   abs-real-denot {e = det} fs ‚äÜ-refl Œª i ‚Üí _ , ùîâ-weaken H‚äÜ‚Ä≤ (xs i .œÄ‚ÇÇ)
  --   where
  --     fs : ‚ü¶ T‚ÇÇ ‚üß·µÄ (cs ++ Œò‚Ä≤)
  --     fs = Hf (‚äÜ-++‚Å∫ ‚äÜ-refl (‚äÜ-trans {zs = Œò‚Ä≤} H‚äÜ H‚äÜ‚Ä≤)) (weaken (‚äÜ-++‚Å∫À° _ ‚äÜ-refl) s)
  -- abs-real-denot {T = ttup n Ts} Hsem H‚äÜ f i = abs-real-denot {e = det} (Hsem i) H‚äÜ f
  -- abs-real-denot {T = tdist T} Hsem H‚äÜ f _ =
  --   abs-real-denot {e = det} (Hsem ‚ÇÄ) H‚äÜ f

  -- app-real-denot : {cs : Coeff ^ n} ‚Üí ‚ü¶ treals n cs ‚áí[ e ] T ‚üß·µÄ Œò ‚Üí ‚ü¶ T ‚üß·µÄ (cs ++ Œò)
  -- app-real-denot f =
  --   f (‚äÜ-++‚Å∫À° _ ‚äÜ-refl) Œª i ‚Üí _ , ùîâ-proj‚Ä≤ (‚äÜ-++‚Å∫ ≥ _ ‚äÜ-refl) i

  -- if-denot : ‚ü¶ treal P ‚üß·µÄ Œò ‚Üí ‚ü¶ T ‚üß·µÄ Œò ‚Üí ‚ü¶ T ‚üß·µÄ Œò ‚Üí ‚ü¶ T ‚üß·µÄ Œò
  -- if-denot {T = treal c} (s , Hs) (s‚ÇÅ , Hs‚ÇÅ) (s‚ÇÇ , Hs‚ÇÇ) =
  --   let g Œ∏ = Œª {‚ÇÄ ‚Üí s Œ∏ ; ‚ÇÅ ‚Üí s‚ÇÅ Œ∏ ; ‚ÇÇ ‚Üí s‚ÇÇ Œ∏ }
  --       Hg = Œª {‚ÇÄ ‚Üí Hs ; ‚ÇÅ ‚Üí Hs‚ÇÅ ; ‚ÇÇ ‚Üí Hs‚ÇÇ }
  --   in
  --   _ , ùîâ-compose {g = g} Hg ùîâ-cond
  -- if-denot {T = T‚ÇÅ ‚áí[ _ ] T‚ÇÇ} s s‚ÇÅ s‚ÇÇ H‚äÜ x =
  --   if-denot (weaken H‚äÜ s) (s‚ÇÅ H‚äÜ x) (s‚ÇÇ H‚äÜ x)
  -- if-denot {T = ttup n Ts} s s‚ÇÅ s‚ÇÇ i = if-denot s (s‚ÇÅ i) (s‚ÇÇ i)
  -- if-denot {T = tdist T} s s‚ÇÅ s‚ÇÇ _ = if-denot s (s‚ÇÅ ‚ÇÄ) (s‚ÇÇ ‚ÇÄ)


  ‚ü¶_‚üß : Œì ‚ä¢ t :[ e ] T ‚Üí ùîá-hom ‚ü¶ Œì ‚üß·¥± ‚ü¶ T ‚üß·µÄ
  ‚ü¶ tvar ‚üß = ùîáœÄ‚ÇÇ {D‚ÇÅ = ùîáùüô}
  ‚ü¶ tabs (–òi As Habs) ‚üß = ùîá-curry ‚ü¶ Habs (new As) {{unfinite As}} ‚üß
  ‚ü¶ tapp Htype Htype‚ÇÅ ‚üß = ùîá-eval ùîá‚àò ùîá‚ü® ‚ü¶ Htype ‚üß , ‚ü¶ Htype‚ÇÅ ‚üß ‚ü©
  ‚ü¶ tprim {œï = œï} {cs = cs} Hœï _ Htypes ‚üß = ùîá-prim Hœï ùîá‚àò ùîá‚àè‚ü® ‚ü¶_‚üß ‚àò Htypes ‚ü©
  ‚ü¶ treal {r = r} ‚üß = ùîá-const r
  ‚ü¶ ttup _ Htypes ‚üß = ùîá‚àè‚ü® ‚ü¶_‚üß ‚àò Htypes ‚ü©
  ‚ü¶ tproj {Ts = Ts} i Htype ‚üß = ùîáœÄ[_] {Ds = ‚ü¶_‚üß·µÄ ‚àò Ts} i ùîá‚àò ‚ü¶ Htype ‚üß
  ‚ü¶ tif Htype Htype‚ÇÅ Htype‚ÇÇ ‚üß = {!!}
  ‚ü¶ tdiff x Htype Htype‚ÇÅ ‚üß = {!!}
  ‚ü¶ tsolve Htype Htype‚ÇÅ Htype‚ÇÇ x ‚üß = {!!}
  ‚ü¶ tdist x x‚ÇÅ x‚ÇÇ ‚üß = {!!}
  ‚ü¶ tassume Htype ‚üß = {!!}
  ‚ü¶ tweight Htype ‚üß = {!!}
  ‚ü¶ tinfer Htype x ‚üß = {!!}
  ‚ü¶ tweaken Htype x x‚ÇÅ ‚üß = {!!}
  ‚ü¶ tsub Htype x x‚ÇÅ ‚üß = {!!}
  ‚ü¶ tpromote Htype x ‚üß = {!!}
  -- ‚ü¶ tvar ‚üß (x All.‚à∑ _) = x
  -- ‚ü¶ tabs (–òi As Habs) ‚üß Œ≥ H‚äÜ s =
  --   ‚ü¶ Habs (new As) {{unfinite As}} ‚üß (s All.‚à∑ weaken-env H‚äÜ Œ≥)
  -- ‚ü¶ tapp Hf Ht ‚üß Œ≥ = ‚ü¶ Hf ‚üß Œ≥ ‚äÜ-refl (‚ü¶ Ht ‚üß Œ≥)
  -- ‚ü¶ tprim {œï = œï} {cs = cs} Hœï _ Htypes ‚üß {Œò} Œ≥ =
  --   _ , ùîâ-compose (Œª i ‚Üí ‚ü¶ Htypes i ‚üß Œ≥ .œÄ‚ÇÇ) (ùîâ-prim Hœï)
  -- ‚ü¶ treal {r = r} ‚üß _ = _ , ùîâ-compose {g = Œª _ ()} (Œª ()) (ùîâ-const r)
  -- ‚ü¶ ttup _ Htypes ‚üß Œ≥ i = ‚ü¶ Htypes i ‚üß Œ≥
  -- ‚ü¶ tproj i Htype ‚üß Œ≥ = ‚ü¶ Htype ‚üß Œ≥ i
  -- ‚ü¶ tif Htype Htype‚ÇÅ Htype‚ÇÇ ‚üß Œ≥ =
  --   if-denot (‚ü¶ Htype ‚üß Œ≥) (‚ü¶ Htype‚ÇÅ ‚üß Œ≥) (‚ü¶ Htype‚ÇÇ ‚üß Œ≥)
  -- ‚ü¶ tdiff {n = n} {m} {cs = cs} {ds} H‚â§ Htype Htype‚ÇÅ ‚üß {Œò} Œ≥ =
  --   abs-real-denot {T = treals m ds} {e = det} Œª j ‚Üí
  --   _ , ùîâ-compose
  --        ((ùîâ-compose‚Ä≤ getŒò (Œª i ‚Üí ‚ü¶ Htype‚ÇÅ ‚üß Œ≥ i .œÄ‚ÇÇ) <++> getAs) <++> getŒò)
  --        (ùîâ-diff _ H‚â§ (fapp _ .œÄ‚ÇÇ))
  --   where
  --     fapp = app-real-denot {e = det} {T = treals m ds} (‚ü¶ Htype ‚üß Œ≥)
  --     _<++>_ = ùîâ-++
  --     getAs = ùîâ-proj‚Ä≤ (‚äÜ-++‚Å∫ ≥ _ ‚äÜ-refl)
  --     getŒò = ùîâ-proj‚Ä≤ (‚äÜ-++‚Å∫À° _ ‚äÜ-refl)
  -- ‚ü¶ tsolve Htype Htype‚ÇÅ Htype‚ÇÇ H‚â§ ‚üß = {!!}
  -- ‚ü¶ tdist _ _ _ ‚üß = {!!}
  -- ‚ü¶ tassume Htype ‚üß Œ≥ = ‚ü¶ Htype ‚üß Œ≥ ‚ÇÄ
  -- ‚ü¶ tweight Htype ‚üß Œ≥ ()
  -- ‚ü¶ tinfer Htype _ ‚üß Œ≥ _ = ‚ü¶ Htype ‚üß Œ≥ ‚äÜ-refl Œª ()
  -- ‚ü¶ tweaken Htype x x‚ÇÅ ‚üß = {!!}
  -- ‚ü¶ tsub Htype x x‚ÇÅ ‚üß = {!!}
  -- ‚ü¶ tpromote Htype x ‚üß = {!!}
