module Lib.Concrete.Construction where

-- Two main constructions on sites and sheaves, which we use to
-- construct our denotations.

open import Lib.Prelude renaming (_âˆ˜_ to _âˆ˜á¶ _)

open import Lib.Concrete.Concrete

open import Categories.Adjoint using (Adjoint ; _âŠ£_)
open import Categories.Adjoint.RAPL using (rapl)
open import Categories.Category using (Category)
open import Categories.Diagram.Empty using (empty)
open import Categories.Diagram.Pullback using (IsPullback)
open import Categories.Functor using (Functor; _âˆ˜F_)
open import Categories.Object.Terminal using (Terminal ; IsTerminal)
open import Categories.Object.Terminal.Limit using (limitâ‡’âŠ¤ ; âŠ¤â‡’limit)

import Categories.Morphism.Reasoning as MR

open import Function using (Func)

open import Relation.Binary.Bundles using (Setoid)
import Relation.Binary.Reasoning.Setoid as SetoidR

open Func

module _ {o â„“ e : Level} where

  -- Left-exactness and geometric morphisms, defined following
  -- https://1lab.dev/Cat.Diagram.Limit.Finite.html
  -- https://1lab.dev/Topoi.Base.html

  record is-lex {C D : Category o â„“ e} (F : Functor C D) : Set (o âŠ” â„“ âŠ” e) where
    open Category C
    open Functor F
    field
      pres-âŠ¤ : âˆ€ {T} â†’ IsTerminal C T â†’ IsTerminal D (Fâ‚€ T)
      pres-pullback
        : âˆ€ {P X Y Z} {pâ‚ : P â‡’ X} {pâ‚‚ : P â‡’ Y}
            {f : X â‡’ Z} {g : Y â‡’ Z}
        â†’ IsPullback C pâ‚ pâ‚‚ f g
        â†’ IsPullback D (Fâ‚ pâ‚) (Fâ‚ pâ‚‚) (Fâ‚ f) (Fâ‚ g)

  record Geom[_,_] (C D : Category o â„“ e) : Set (o âŠ” â„“ âŠ” e) where
    field
      Inv[_]  : Functor D C
      Dir[_]  : Functor C D
      Inv-lex : is-lex Inv[_]
      InvâŠ£Dir : Inv[_] âŠ£ Dir[_]


module Pull {o â„“ e i p : Level} {ğ’ ğ’Ÿ : CCat o â„“ e} (S : CSite ğ’ i p) where
  -- We define a notion of induced topology, where a topology on ğ’ is pulled
  -- back to form a topology on ğ’Ÿ given a geometric morphism from ğ’Ÿ to ğ’.
  -- Sheaves on ğ’ are also pulled back to form sheaves on ğ’Ÿ.
  --
  -- In particular, the induced topology makes a sieve S on U open in ğ’Ÿ
  -- if and only if the sieve R* S on R U is open in ğ’, where we have
  -- g âˆˆ R* S  âŸº  Radjunct g âˆˆ S.
  --
  -- Note that the above definition is equivalent to
  -- g âˆˆ R* S  âŸº  g âˆˆ âŸ¨ R f âˆ£ f âˆˆ S âŸ©,
  -- where âŸ¨ X âŸ© denotes the sieve generated by the maps in X.  Hence,
  -- it may not be necessary to require a geometric morphism, it may
  -- suffice if R is continuous (in the limit-preserving sense), for
  -- example.  An additional observation in this vein is that the
  -- Stacks project (https://stacks.math.columbia.edu/tag/00X0)
  -- defines a morphism of sites ğ’ â†’ ğ’Ÿ to be a continuous functor f :
  -- ğ’Ÿ â†’ ğ’ (notice the order-reversal of ğ’Ÿ and ğ’).  Thus, it may be
  -- more correct to think of this construction as a pushforward along
  -- a candidate morphism ğ’ â†’ D inducing the coarsest topology making
  -- the functor continuous.  The pullback sheaf construction is then
  -- just the functor of sheaves induced by our newly formed morphism
  -- of sites.
  --
  -- In any case, assuming that we have an adjunction streamlines the
  -- definitions, and is general enough for our application.

  open CSite using (covering ; is-stable ; is-concrete ; is-maximal ; is-local)
  module C = CCat ğ’
  module D = CCat ğ’Ÿ
  module S = CSite S

  open Sieve D.Cat

  module _ (G : Geom[ D.Cat , C.Cat ]) where
    open is-lex
    open Geom[_,_]

    private
      module L = Functor Inv[ G ]
      module R = Functor Dir[ G ]
      module LR = Functor (Inv[ G ] âˆ˜F Dir[ G ])
      module RL = Functor (Dir[ G ] âˆ˜F Inv[ G ])
      open Adjoint (InvâŠ£Dir G)

      module DR = D.HomReasoning
      module CR = C.HomReasoning

      LH = L.homomorphism
      RH = R.homomorphism

      abstract
        Râ‹†-is-terminal : IsTerminal C.Cat (R.â‚€ D.â‹†)
        Râ‹†-is-terminal = âŠ¤-is-terminal Râ‹†-terminal
          where
            open Terminal
            Râ‹†-terminal : Terminal C.Cat
            Râ‹†-terminal =
              limitâ‡’âŠ¤ C.Cat $
              rapl (InvâŠ£Dir G) (empty _ o â„“ e) $
              âŠ¤â‡’limit D.Cat D.terminal

      Lâ‹†-is-terminal = Inv-lex G .pres-âŠ¤ C.â‹†-is-terminal
      Lâ‹†-terminal = record { âŠ¤ = _ ; âŠ¤-is-terminal = Lâ‹†-is-terminal }

      module Râ‹† = IsTerminal Râ‹†-is-terminal
      module Lâ‹† = IsTerminal Lâ‹†-is-terminal

      R* : âˆ€ {U} â†’ Sieve U i â†’ S.Sieve (R.â‚€ U) i
      R* S .arrows g = Radjunct g âˆˆË¢ S
      R* S .closed Hf g = resp-â‰ˆ S (D.assoc DR.â—‹ D.âˆ˜-resp-â‰ˆÊ³ (DR.âŸº LH))
                                   (closed S Hf (L.â‚ g))
      R* S .resp-â‰ˆ Hâ‰ˆ Hf = resp-â‰ˆ S (D.âˆ˜-resp-â‰ˆÊ³ (L.F-resp-â‰ˆ Hâ‰ˆ)) Hf

    PullSite : CSite ğ’Ÿ i p
    PullSite .covering U R = R.â‚€ U S.â—€ R* R
    PullSite .is-stable g {R} HR =
      S.upward-closed (S.is-stable (R.â‚ g) HR) Î» Hâˆˆ â†’
        R .resp-â‰ˆ (D.âˆ˜-resp-â‰ˆÊ³ LH DR.â—‹ extendÊ³ (counit.commute _)) Hâˆˆ
      where open MR D.Cat
    PullSite .is-concrete {R = R} HR x =
      let V , f , Hf , y , Hâ‰ˆ = S.is-concrete HR (R.â‚ x C.âˆ˜ Râ‹†.!)
          Hâ‰ˆâ€² = begin
            x                                             â‰ˆâŸ¨ introÊ³ D.!-uniqueâ‚‚ âŸ©
            x D.âˆ˜ Radjunct Râ‹†.! D.âˆ˜ Lâ‹†.!                  â‰ˆâŸ¨ extendÊ³ (extendÊ³ (counit.sym-commute _)) âŸ©
            counit.Î· _ D.âˆ˜ (LR.â‚ x D.âˆ˜ L.â‚ Râ‹†.!) D.âˆ˜ Lâ‹†.! â‰ˆâŸ¨ reflâŸ©âˆ˜âŸ¨ (âŸº LH â—‹ L.F-resp-â‰ˆ Hâ‰ˆ) âŸ©âˆ˜âŸ¨refl âŸ©
            counit.Î· _ D.âˆ˜ L.Fâ‚ (f C.âˆ˜ y) D.âˆ˜ Lâ‹†.!        â‰ˆâŸ¨ D.sym-assoc âŸ©
            Radjunct (f C.âˆ˜ y) D.âˆ˜ Lâ‹†.!                   âˆ
      in L.â‚€ C.â‹†
       , Radjunct (f C.âˆ˜ y)
       , R .resp-â‰ˆ (D.assoc â—‹ D.âˆ˜-resp-â‰ˆÊ³ (âŸº LH)) (R .closed Hf _)
       , Lâ‹†.!
       , Hâ‰ˆâ€²
     where open D.HomReasoning
           open MR D.Cat
    PullSite .is-maximal {R = R} Hid =
      S.is-maximal (R .resp-â‰ˆ D.identityË¡ (R .closed Hid _))
    PullSite .is-local {U} {R} {S} HR HS =
      let HSâ€² : âˆ€ {V} {f : V C.â‡’ R.â‚€ U}
              â†’ f S.âˆˆË¢ R* R â†’ V S.â—€ S.pullback f (R* S)
          HSâ€² = Î» {_ f} Hf â†’
            S.upward-closed (S.is-stable (unit.Î· _) (HS Hf)) Î» {_ x} Hâˆˆ â†’
              let Hâ‰ˆ = begin
                    Radjunct f D.âˆ˜ Radjunct (unit.Î· _ C.âˆ˜ x) â‰ˆâŸ¨ reflâŸ©âˆ˜âŸ¨ reflâŸ©âˆ˜âŸ¨ LH âŸ©
                    Radjunct f D.âˆ˜ _ D.âˆ˜ _ D.âˆ˜ L.â‚ x         â‰ˆâŸ¨ reflâŸ©âˆ˜âŸ¨ (D.sym-assoc â—‹ elimË¡ zig) âŸ©
                    Radjunct f D.âˆ˜ L.â‚ x                     â‰ˆâŸ¨ D.assoc â—‹ D.âˆ˜-resp-â‰ˆÊ³ (âŸº LH) âŸ©
                    Radjunct (f C.âˆ˜ x)                       âˆ
              in
              S .resp-â‰ˆ Hâ‰ˆ Hâˆˆ
      in
      S.is-local HR HSâ€²
      where open D.HomReasoning
            open MR D.Cat

    module _
      {oâ€² eâ€² : Level}
      (F : CSheaf S oâ€² eâ€²)
      where

      private
        module F = CSheaf F
        open CSheaf using (Psh ; is-sheaf ; is-concrete)
        open F.Parts

        FH = F.homomorphism

        RLâ‹†-!-unique : âˆ€ {U} {f : U C.â‡’ RL.â‚€ C.â‹†} â†’ R.â‚ Lâ‹†.! C.âˆ˜ Râ‹†.! C.â‰ˆ f
        RLâ‹†-!-unique {f = f} = begin
          R.â‚ Lâ‹†.! C.âˆ˜ Râ‹†.!          â‰ˆâŸ¨ reflâŸ©âˆ˜âŸ¨ Râ‹†.!-uniqueâ‚‚ âŸ©
          R.â‚ Lâ‹†.! C.âˆ˜ R.â‚ D.! C.âˆ˜ f â‰ˆâŸ¨ pullË¡ (âŸº RH) âŸ©
          R.â‚ (Lâ‹†.! D.âˆ˜ D.!) C.âˆ˜ f   â‰ˆâŸ¨ R.F-resp-â‰ˆ Lâ‹†.!-uniqueâ‚‚ âŸ©âˆ˜âŸ¨refl âŸ©
          R.â‚ D.id C.âˆ˜ f             â‰ˆâŸ¨ elimË¡ R.identity âŸ©
          f                          âˆ
          where open C.HomReasoning
                open MR C.Cat

        Radjunct-lemma : âˆ€ {X} {z : C.â‹† C.â‡’ R.â‚€ X} â†’ R.â‚ (Radjunct z D.âˆ˜ Lâ‹†.!) C.âˆ˜ Râ‹†.! C.â‰ˆ z
        Radjunct-lemma {z = z} = begin
          R.â‚ (Radjunct z D.âˆ˜ Lâ‹†.!) C.âˆ˜ Râ‹†.!     â‰ˆâŸ¨ C.âˆ˜-resp-â‰ˆË¡ RH â—‹ C.assoc âŸ©
          R.â‚ (Radjunct z) C.âˆ˜ R.â‚ Lâ‹†.! C.âˆ˜ Râ‹†.! â‰ˆâŸ¨ reflâŸ©âˆ˜âŸ¨ RLâ‹†-!-unique âŸ©
          Ladjunct (Radjunct z)                  â‰ˆâŸ¨ LRadjunctâ‰ˆid âŸ©
          z                                      âˆ
          where open C.HomReasoning

      PullSheaf : CSheaf PullSite oâ€² eâ€²
      PullSheaf .Psh = F.Psh âˆ˜F R.op
      PullSheaf .is-sheaf {U} {R} HR p matching =
        mkUnique (uniq-section .witness) sectionâ€² uniqueâ€²
        where
          pâ€² : F.Parts (R* R)
          pâ€² = record
            { to = Î» {V} Hf â†’ F.â‚ (unit.Î· V) .to (p .to Hf)
            ; cong = Î» Hâ‰ˆ â†’
              F.â‚ (unit.Î· _) .cong $ p .cong $ D.âˆ˜-resp-â‰ˆÊ³ $ L.F-resp-â‰ˆ Hâ‰ˆ
            }
          matchingâ€² : F.is-matching (R* R) pâ€²
          matchingâ€² {W = W} {f} Hf {g} Hgf = begin
            F.â‚ g .to (F.â‚ (unit.Î· _) .to (p .to Hf)) â‰ˆâŸ¨ FW.sym FH â—‹ (F.F-resp-â‰ˆ (unit.commute _) â—‹ FH) âŸ©
            F.â‚ _ .to (F.â‚ (RL.â‚ g) .to (p .to Hf))   â‰ˆâŸ¨ F.Fâ‚ (unit.Î· _) .cong $ matching _ _ âŸ©
            F.â‚ _ .to (p .to (R .closed Hf _))        â‰ˆâŸ¨ F.Fâ‚ (unit.Î· _) .cong $ p .cong Hâ‰ˆâ€² âŸ©
            F.â‚ (unit.Î· _) .to (p .to Hgf)            âˆ
            where open SetoidR (F.â‚€ W)
                  module FW = Setoid (F.â‚€ W)
                  _â—‹_ = FW.trans
                  Hâ‰ˆâ€² = D.assoc DR.â—‹ D.âˆ˜-resp-â‰ˆÊ³ (DR.âŸº LH)
          uniq-section : âˆƒ! (F.â‚€ (R.â‚€ U)) (F.is-section (R* R) pâ€²)
          uniq-section = F.is-sheaf HR pâ€² matchingâ€²
          open Matching (F.Psh âˆ˜F R.op)
          sectionâ€² : is-section _ p (uniq-section .witness)
          sectionâ€² {V} {f} Hf = begin
            F.â‚ (R.â‚ f) .to (uniq-section .witness)                    â‰ˆâŸ¨ uniq-section .has-prop Hfâ‚‚ âŸ©
            F.â‚ (unit.Î· _) .to (p .to Hfâ‚‚)                             â‰ˆâŸ¨ F.â‚ (unit.Î· _) .cong $ p .cong (counit.commute f) âŸ©
            F.â‚ (unit.Î· _) .to (p .to Hfâ‚)                             â‰ˆâŸ¨ F.â‚ (unit.Î· _) .cong $ FVâ€².sym $ matching _ _ âŸ©
            F.â‚ (unit.Î· _) .to (F.â‚ (R.â‚ (counit.Î· _)) .to (p .to Hf)) â‰ˆâŸ¨ FV.sym FH â—‹ (F.F-resp-â‰ˆ zag â—‹ F.identity) âŸ©
            p .to Hf                                                   âˆ
            where open SetoidR (F.â‚€ (R.â‚€ V))
                  module FV  = Setoid (F.â‚€ (R.â‚€ V))
                  module FVâ€² = Setoid (F.â‚€ (R.â‚€ (LR.â‚€ V)))
                  _â—‹_ = FV.trans
                  Hfâ‚ = R .closed Hf (counit.Î· _)
                  Hfâ‚‚ = R .resp-â‰ˆ (counit.sym-commute f) Hfâ‚
          module FU = Setoid (F.â‚€ (R.â‚€ U))
          uniqueâ€² : âˆ€ s â†’ is-section _ p s â†’ uniq-section .witness FU.â‰ˆ s
          uniqueâ€² s Hs = uniq-section .unique s Î» {V f} Hf â†’
            let module FD = Setoid (F.â‚€ V)
                _â—‹_ = FD.trans
            in F.F-resp-â‰ˆ (CR.âŸº LRadjunctâ‰ˆid) â—‹ (FH â—‹ F.Fâ‚ (unit.Î· _) .cong (Hs Hf))
      PullSheaf .is-concrete {x = x} {y} Hâ‰ˆ =
        F.is-concrete Î» {z} â†’ begin
          F.â‚ z .to x                      â‰ˆâŸ¨ F.F-resp-â‰ˆ (CR.âŸº Radjunct-lemma) â—‹ FH âŸ©
          F.â‚ Râ‹†.! .to (F.â‚ (R.â‚ _) .to x) â‰ˆâŸ¨ F.â‚ Râ‹†.! .cong Hâ‰ˆ âŸ©
          F.â‚ Râ‹†.! .to (F.â‚ (R.â‚ _) .to y) â‰ˆâŸ¨ F.X.sym FH â—‹ F.F-resp-â‰ˆ Radjunct-lemma âŸ©
          F.â‚ z .to y                      âˆ
        where open SetoidR (F.â‚€ C.â‹†)
              _â—‹_ = F.X.trans


module Meet {o â„“ e i p : Level}
  {ğ’ : CCat o â„“ e}
  (Sâ‚ : CSite ğ’ i p)
  (Sâ‚‚ : CSite ğ’ i p)
  where
  -- Our second construction is more straightforward: the intersection
  -- of topologies is again a topology.

  open CSite using (covering ; is-stable ; is-concrete ; is-maximal ; is-local)
  open CCat ğ’
  open HomReasoning
  open MR Cat

  private
    module Sâ‚ = CSite Sâ‚
    module Sâ‚‚ = CSite Sâ‚‚

  MeetSite : CSite ğ’ i p
  MeetSite .covering U R = U Sâ‚.â—€ R Ã— U Sâ‚‚.â—€ R
  MeetSite .is-stable g (HRâ‚ , HRâ‚‚) = Sâ‚.is-stable g HRâ‚ , Sâ‚‚.is-stable g HRâ‚‚
  MeetSite .is-concrete = Î» HR â†’ Sâ‚.is-concrete (HR .Ï€â‚)
  MeetSite .is-maximal = Î» Hid â†’ Sâ‚.is-maximal Hid , Sâ‚‚.is-maximal Hid
  MeetSite .is-local (HRâ‚ , HRâ‚‚) HS =
    Sâ‚.is-local HRâ‚ (Ï€â‚ âˆ˜á¶  HS) , Sâ‚‚.is-local HRâ‚‚ (Ï€â‚‚ âˆ˜á¶  HS)

  open CSheaf using (Psh ; is-sheaf ; is-concrete)

  module _
    {oâ€² eâ€² : Level}
    (F : CSheaf Sâ‚ oâ€² eâ€²)
    where
    private
      module F = CSheaf F

    MeetSheafâ‚ : CSheaf MeetSite oâ€² eâ€²
    MeetSheafâ‚ .Psh = F.Psh
    MeetSheafâ‚ .is-sheaf (HRâ‚ , _) p matching = F.is-sheaf HRâ‚ p matching
    MeetSheafâ‚ .is-concrete = F.is-concrete

  module _
    {oâ€² eâ€² : Level}
    (F : CSheaf Sâ‚‚ oâ€² eâ€²)
    where
    private
      module F = CSheaf F

    MeetSheafâ‚‚ : CSheaf MeetSite oâ€² eâ€²
    MeetSheafâ‚‚ .Psh = F.Psh
    MeetSheafâ‚‚ .is-sheaf (_ , HRâ‚‚) p matching = F.is-sheaf HRâ‚‚ p matching
    MeetSheafâ‚‚ .is-concrete = F.is-concrete
