module Lib.Concrete.Construction where

-- Two main constructions on sites and sheaves, which we use to
-- construct our denotations.

open import Lib.Prelude renaming (_∘_ to _∘ᶠ_)

open import Lib.Concrete.Concrete

open import Categories.Adjoint using (Adjoint ; _⊣_)
open import Categories.Adjoint.RAPL using (rapl)
open import Categories.Category using (Category)
open import Categories.Diagram.Empty using (empty)
open import Categories.Diagram.Pullback using (IsPullback)
open import Categories.Functor using (Functor; _∘F_)
open import Categories.Object.Terminal using (Terminal ; IsTerminal)
open import Categories.Object.Terminal.Limit using (limit⇒⊤ ; ⊤⇒limit)

import Categories.Morphism.Reasoning as MR

open import Function using (Func)

open import Relation.Binary.Bundles using (Setoid)
import Relation.Binary.Reasoning.Setoid as SetoidR

open Func

module _ {o ℓ e : Level} where

  -- Left-exactness and geometric morphisms, defined following
  -- https://1lab.dev/Cat.Diagram.Limit.Finite.html
  -- https://1lab.dev/Topoi.Base.html

  record is-lex {C D : Category o ℓ e} (F : Functor C D) : Set (o ⊔ ℓ ⊔ e) where
    open Category C
    open Functor F
    field
      pres-⊤ : ∀ {T} → IsTerminal C T → IsTerminal D (F₀ T)
      pres-pullback
        : ∀ {P X Y Z} {p₁ : P ⇒ X} {p₂ : P ⇒ Y}
            {f : X ⇒ Z} {g : Y ⇒ Z}
        → IsPullback C p₁ p₂ f g
        → IsPullback D (F₁ p₁) (F₁ p₂) (F₁ f) (F₁ g)

  record Geom[_,_] (C D : Category o ℓ e) : Set (o ⊔ ℓ ⊔ e) where
    field
      Inv[_]  : Functor D C
      Dir[_]  : Functor C D
      Inv-lex : is-lex Inv[_]
      Inv⊣Dir : Inv[_] ⊣ Dir[_]


module Pull {o ℓ e i p : Level} {𝒞 𝒟 : CCat o ℓ e} (S : CSite 𝒞 i p) where
  -- We define a notion of induced topology, where a topology on 𝒞 is pulled
  -- back to form a topology on 𝒟 given a geometric morphism from 𝒟 to 𝒞.
  -- Sheaves on 𝒞 are also pulled back to form sheaves on 𝒟.
  --
  -- In particular, the induced topology makes a sieve S on U open in 𝒟
  -- if and only if the sieve R* S on R U is open in 𝒞, where we have
  -- g ∈ R* S  ⟺  Radjunct g ∈ S.
  --
  -- Note that the above definition is equivalent to
  -- g ∈ R* S  ⟺  g ∈ ⟨ R f ∣ f ∈ S ⟩,
  -- where ⟨ X ⟩ denotes the sieve generated by the maps in X.  Hence,
  -- it may not be necessary to require a geometric morphism, it may
  -- suffice if R is continuous (in the limit-preserving sense), for
  -- example.  An additional observation in this vein is that the
  -- Stacks project (https://stacks.math.columbia.edu/tag/00X0)
  -- defines a morphism of sites 𝒞 → 𝒟 to be a continuous functor f :
  -- 𝒟 → 𝒞 (notice the order-reversal of 𝒟 and 𝒞).  Thus, it may be
  -- more correct to think of this construction as a pushforward along
  -- a candidate morphism 𝒞 → D inducing the coarsest topology making
  -- the functor continuous.  The pullback sheaf construction is then
  -- just the functor of sheaves induced by our newly formed morphism
  -- of sites.
  --
  -- In any case, assuming that we have an adjunction streamlines the
  -- definitions, and is general enough for our application.

  open CSite using (covering ; is-stable ; is-concrete ; is-maximal ; is-local)
  module C = CCat 𝒞
  module D = CCat 𝒟
  module S = CSite S

  open Sieve D.Cat

  module _ (G : Geom[ D.Cat , C.Cat ]) where
    open is-lex
    open Geom[_,_]

    private
      module L = Functor Inv[ G ]
      module R = Functor Dir[ G ]
      module LR = Functor (Inv[ G ] ∘F Dir[ G ])
      module RL = Functor (Dir[ G ] ∘F Inv[ G ])
      open Adjoint (Inv⊣Dir G)

      module DR = D.HomReasoning
      module CR = C.HomReasoning

      LH = L.homomorphism
      RH = R.homomorphism

      abstract
        R⋆-is-terminal : IsTerminal C.Cat (R.₀ D.⋆)
        R⋆-is-terminal = ⊤-is-terminal R⋆-terminal
          where
            open Terminal
            R⋆-terminal : Terminal C.Cat
            R⋆-terminal =
              limit⇒⊤ C.Cat $
              rapl (Inv⊣Dir G) (empty _ o ℓ e) $
              ⊤⇒limit D.Cat D.terminal

      L⋆-is-terminal = Inv-lex G .pres-⊤ C.⋆-is-terminal
      L⋆-terminal = record { ⊤ = _ ; ⊤-is-terminal = L⋆-is-terminal }

      module R⋆ = IsTerminal R⋆-is-terminal
      module L⋆ = IsTerminal L⋆-is-terminal

      R* : ∀ {U} → Sieve U i → S.Sieve (R.₀ U) i
      R* S .arrows g = Radjunct g ∈ˢ S
      R* S .closed Hf g = resp-≈ S (D.assoc DR.○ D.∘-resp-≈ʳ (DR.⟺ LH))
                                   (closed S Hf (L.₁ g))
      R* S .resp-≈ H≈ Hf = resp-≈ S (D.∘-resp-≈ʳ (L.F-resp-≈ H≈)) Hf

    PullSite : CSite 𝒟 i p
    PullSite .covering U R = R.₀ U S.◀ R* R
    PullSite .is-stable g {R} HR =
      S.upward-closed (S.is-stable (R.₁ g) HR) λ H∈ →
        R .resp-≈ (D.∘-resp-≈ʳ LH DR.○ extendʳ (counit.commute _)) H∈
      where open MR D.Cat
    PullSite .is-concrete {R = R} HR x =
      let V , f , Hf , y , H≈ = S.is-concrete HR (R.₁ x C.∘ R⋆.!)
          H≈′ = begin
            x                                             ≈⟨ introʳ D.!-unique₂ ⟩
            x D.∘ Radjunct R⋆.! D.∘ L⋆.!                  ≈⟨ extendʳ (extendʳ (counit.sym-commute _)) ⟩
            counit.η _ D.∘ (LR.₁ x D.∘ L.₁ R⋆.!) D.∘ L⋆.! ≈⟨ refl⟩∘⟨ (⟺ LH ○ L.F-resp-≈ H≈) ⟩∘⟨refl ⟩
            counit.η _ D.∘ L.F₁ (f C.∘ y) D.∘ L⋆.!        ≈⟨ D.sym-assoc ⟩
            Radjunct (f C.∘ y) D.∘ L⋆.!                   ∎
      in L.₀ C.⋆
       , Radjunct (f C.∘ y)
       , R .resp-≈ (D.assoc ○ D.∘-resp-≈ʳ (⟺ LH)) (R .closed Hf _)
       , L⋆.!
       , H≈′
     where open D.HomReasoning
           open MR D.Cat
    PullSite .is-maximal {R = R} Hid =
      S.is-maximal (R .resp-≈ D.identityˡ (R .closed Hid _))
    PullSite .is-local {U} {R} {S} HR HS =
      let HS′ : ∀ {V} {f : V C.⇒ R.₀ U}
              → f S.∈ˢ R* R → V S.◀ S.pullback f (R* S)
          HS′ = λ {_ f} Hf →
            S.upward-closed (S.is-stable (unit.η _) (HS Hf)) λ {_ x} H∈ →
              let H≈ = begin
                    Radjunct f D.∘ Radjunct (unit.η _ C.∘ x) ≈⟨ refl⟩∘⟨ refl⟩∘⟨ LH ⟩
                    Radjunct f D.∘ _ D.∘ _ D.∘ L.₁ x         ≈⟨ refl⟩∘⟨ (D.sym-assoc ○ elimˡ zig) ⟩
                    Radjunct f D.∘ L.₁ x                     ≈⟨ D.assoc ○ D.∘-resp-≈ʳ (⟺ LH) ⟩
                    Radjunct (f C.∘ x)                       ∎
              in
              S .resp-≈ H≈ H∈
      in
      S.is-local HR HS′
      where open D.HomReasoning
            open MR D.Cat

    module _
      {o′ e′ : Level}
      (F : CSheaf S o′ e′)
      where

      private
        module F = CSheaf F
        open CSheaf using (Psh ; is-sheaf ; is-concrete)
        open F.Parts

        FH = F.homomorphism

        RL⋆-!-unique : ∀ {U} {f : U C.⇒ RL.₀ C.⋆} → R.₁ L⋆.! C.∘ R⋆.! C.≈ f
        RL⋆-!-unique {f = f} = begin
          R.₁ L⋆.! C.∘ R⋆.!          ≈⟨ refl⟩∘⟨ R⋆.!-unique₂ ⟩
          R.₁ L⋆.! C.∘ R.₁ D.! C.∘ f ≈⟨ pullˡ (⟺ RH) ⟩
          R.₁ (L⋆.! D.∘ D.!) C.∘ f   ≈⟨ R.F-resp-≈ L⋆.!-unique₂ ⟩∘⟨refl ⟩
          R.₁ D.id C.∘ f             ≈⟨ elimˡ R.identity ⟩
          f                          ∎
          where open C.HomReasoning
                open MR C.Cat

        Radjunct-lemma : ∀ {X} {z : C.⋆ C.⇒ R.₀ X} → R.₁ (Radjunct z D.∘ L⋆.!) C.∘ R⋆.! C.≈ z
        Radjunct-lemma {z = z} = begin
          R.₁ (Radjunct z D.∘ L⋆.!) C.∘ R⋆.!     ≈⟨ C.∘-resp-≈ˡ RH ○ C.assoc ⟩
          R.₁ (Radjunct z) C.∘ R.₁ L⋆.! C.∘ R⋆.! ≈⟨ refl⟩∘⟨ RL⋆-!-unique ⟩
          Ladjunct (Radjunct z)                  ≈⟨ LRadjunct≈id ⟩
          z                                      ∎
          where open C.HomReasoning

      PullSheaf : CSheaf PullSite o′ e′
      PullSheaf .Psh = F.Psh ∘F R.op
      PullSheaf .is-sheaf {U} {R} HR p matching =
        mkUnique (uniq-section .witness) section′ unique′
        where
          p′ : F.Parts (R* R)
          p′ = record
            { to = λ {V} Hf → F.₁ (unit.η V) .to (p .to Hf)
            ; cong = λ H≈ →
              F.₁ (unit.η _) .cong $ p .cong $ D.∘-resp-≈ʳ $ L.F-resp-≈ H≈
            }
          matching′ : F.is-matching (R* R) p′
          matching′ {W = W} {f} Hf {g} Hgf = begin
            F.₁ g .to (F.₁ (unit.η _) .to (p .to Hf)) ≈⟨ FW.sym FH ○ (F.F-resp-≈ (unit.commute _) ○ FH) ⟩
            F.₁ _ .to (F.₁ (RL.₁ g) .to (p .to Hf))   ≈⟨ F.F₁ (unit.η _) .cong $ matching _ _ ⟩
            F.₁ _ .to (p .to (R .closed Hf _))        ≈⟨ F.F₁ (unit.η _) .cong $ p .cong H≈′ ⟩
            F.₁ (unit.η _) .to (p .to Hgf)            ∎
            where open SetoidR (F.₀ W)
                  module FW = Setoid (F.₀ W)
                  _○_ = FW.trans
                  H≈′ = D.assoc DR.○ D.∘-resp-≈ʳ (DR.⟺ LH)
          uniq-section : ∃! (F.₀ (R.₀ U)) (F.is-section (R* R) p′)
          uniq-section = F.is-sheaf HR p′ matching′
          open Matching (F.Psh ∘F R.op)
          section′ : is-section _ p (uniq-section .witness)
          section′ {V} {f} Hf = begin
            F.₁ (R.₁ f) .to (uniq-section .witness)                    ≈⟨ uniq-section .has-prop Hf₂ ⟩
            F.₁ (unit.η _) .to (p .to Hf₂)                             ≈⟨ F.₁ (unit.η _) .cong $ p .cong (counit.commute f) ⟩
            F.₁ (unit.η _) .to (p .to Hf₁)                             ≈⟨ F.₁ (unit.η _) .cong $ FV′.sym $ matching _ _ ⟩
            F.₁ (unit.η _) .to (F.₁ (R.₁ (counit.η _)) .to (p .to Hf)) ≈⟨ FV.sym FH ○ (F.F-resp-≈ zag ○ F.identity) ⟩
            p .to Hf                                                   ∎
            where open SetoidR (F.₀ (R.₀ V))
                  module FV  = Setoid (F.₀ (R.₀ V))
                  module FV′ = Setoid (F.₀ (R.₀ (LR.₀ V)))
                  _○_ = FV.trans
                  Hf₁ = R .closed Hf (counit.η _)
                  Hf₂ = R .resp-≈ (counit.sym-commute f) Hf₁
          module FU = Setoid (F.₀ (R.₀ U))
          unique′ : ∀ s → is-section _ p s → uniq-section .witness FU.≈ s
          unique′ s Hs = uniq-section .unique s λ {V f} Hf →
            let module FD = Setoid (F.₀ V)
                _○_ = FD.trans
            in F.F-resp-≈ (CR.⟺ LRadjunct≈id) ○ (FH ○ F.F₁ (unit.η _) .cong (Hs Hf))
      PullSheaf .is-concrete {x = x} {y} H≈ =
        F.is-concrete λ {z} → begin
          F.₁ z .to x                      ≈⟨ F.F-resp-≈ (CR.⟺ Radjunct-lemma) ○ FH ⟩
          F.₁ R⋆.! .to (F.₁ (R.₁ _) .to x) ≈⟨ F.₁ R⋆.! .cong H≈ ⟩
          F.₁ R⋆.! .to (F.₁ (R.₁ _) .to y) ≈⟨ F.X.sym FH ○ F.F-resp-≈ Radjunct-lemma ⟩
          F.₁ z .to y                      ∎
        where open SetoidR (F.₀ C.⋆)
              _○_ = F.X.trans


module Meet {o ℓ e i p : Level}
  {𝒞 : CCat o ℓ e}
  (S₁ : CSite 𝒞 i p)
  (S₂ : CSite 𝒞 i p)
  where
  -- Our second construction is more straightforward: the intersection
  -- of topologies is again a topology.

  open CSite using (covering ; is-stable ; is-concrete ; is-maximal ; is-local)
  open CCat 𝒞
  open HomReasoning
  open MR Cat

  private
    module S₁ = CSite S₁
    module S₂ = CSite S₂

  MeetSite : CSite 𝒞 i p
  MeetSite .covering U R = U S₁.◀ R × U S₂.◀ R
  MeetSite .is-stable g (HR₁ , HR₂) = S₁.is-stable g HR₁ , S₂.is-stable g HR₂
  MeetSite .is-concrete = λ HR → S₁.is-concrete (HR .π₁)
  MeetSite .is-maximal = λ Hid → S₁.is-maximal Hid , S₂.is-maximal Hid
  MeetSite .is-local (HR₁ , HR₂) HS =
    S₁.is-local HR₁ (π₁ ∘ᶠ HS) , S₂.is-local HR₂ (π₂ ∘ᶠ HS)

  open CSheaf using (Psh ; is-sheaf ; is-concrete)

  module _
    {o′ e′ : Level}
    (F : CSheaf S₁ o′ e′)
    where
    private
      module F = CSheaf F

    MeetSheaf₁ : CSheaf MeetSite o′ e′
    MeetSheaf₁ .Psh = F.Psh
    MeetSheaf₁ .is-sheaf (HR₁ , _) p matching = F.is-sheaf HR₁ p matching
    MeetSheaf₁ .is-concrete = F.is-concrete

  module _
    {o′ e′ : Level}
    (F : CSheaf S₂ o′ e′)
    where
    private
      module F = CSheaf F

    MeetSheaf₂ : CSheaf MeetSite o′ e′
    MeetSheaf₂ .Psh = F.Psh
    MeetSheaf₂ .is-sheaf (_ , HR₂) p matching = F.is-sheaf HR₂ p matching
    MeetSheaf₂ .is-concrete = F.is-concrete
